<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lab 2: Building Mr. Roboto ‚Äì Session 2</title>
<style>
body { font-family: Arial, sans-serif; background-color:#121212; color:#e0e0e0; margin:0; padding:0; font-size:1.05em;}
header { background-color:#000; padding:40px 20px; text-align:center; }
header h1 { color:#c29fff; margin:0; }
header p { color:#bbbbbb; margin:5px 0 20px 0; }
nav { background-color:#111; padding:14px 0; text-align:center; position:sticky; top:0; z-index:100; }
nav a { margin:0 20px; text-decoration:none; color:#fff; font-weight:bold; font-size:1.1em; }
nav a:hover { color:#c29fff; }
.container { display:flex; flex-wrap:wrap; justify-content:space-between; width:90%; max-width:1300px; margin:25px auto; gap:20px; }
.main-content { flex:3; min-width:300px; }
.sidebar { flex:1; min-width:250px; background-color:#1e1e2e; padding:10px; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.5); display:flex; flex-direction:column; align-items:center; }
.sidebar img { width:100%; max-width:400px; border-radius:8px; margin-bottom:10px; }
.section { background-color:#1e1e2e; padding:25px; margin-bottom:20px; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.5); }
.section h2 { color:#c29fff; margin-top:0; }
.checkoff { color:red; font-weight:bold; }
img.inline { width:100%; border-radius:8px; margin:10px 0; }
img.small { width:80%; border-radius:8px; margin:10px 0; }

/* Code blocks */
pre {
  background:#0f0f16;
  color:#e8e8e8;
  padding:12px;
  border-radius:6px;
  overflow:auto;
}
code {
  font-family: "Courier New", Courier, monospace;
}

footer { text-align:center; padding:20px; background-color:#111; color:#bbbbbb; margin-top:20px; font-size:0.9em; }

@media(max-width:1000px){.container{flex-direction:column;}}
  /* MOBILE / OVERFLOW FIXES */

/* MOBILE / OVERFLOW FIXES (paste near end of your <style>) */

/* ensure the page doesn't accidentally grow wider than the screen */
html, body {
  max-width: 100%;
  overflow-x: hidden;
  box-sizing: border-box;
}

/* make all images scale and never exceed their container */
img, .inline-img, .sidebar img {
  max-width: 100%;
  width: 100%;
  height: auto;
  display: block;
}

/* allow long code lines to wrap on small screens instead of forcing horizontal scroll */
pre {
  white-space: pre-wrap;      /* wrap long lines */
  word-break: break-word;     /* break long words/URLs if needed */
  overflow-wrap: anywhere;    /* extra break behavior */
}

/* allow inline code to wrap if necessary */
code {
  white-space: pre-wrap;
  word-break: break-word;
}

/* on very small screens allow flex children to shrink below min-width */
@media (max-width: 600px) {
  .main-content, .sidebar {
    min-width: 0;     /* allow flex children to shrink */
  }
  .container {
    padding-left: 12px;
    padding-right: 12px;
    width: calc(100% - 24px);
  }
}




</style>
</head>
<body>

<header>
<h1>Lab 2: Building Mr. Roboto (Part 2)</h1>
<p>Session 2 ‚Äî Sensors & Closed-Loop Control</p>
</header>

<nav>
  <a href="index.html">Home</a>
  <a href="lab.html">Labs</a>
  <a href="#instructors">Instructors</a>
  <a href="#about">About</a>
</nav>

<div class="container">
  <div class="main-content">

    <!-- INTRO -->
    <div class="section">
      <h2>Introduction</h2>
      <p>This is the second in a series of two labs introducing you to building and programming your own robot. In this lab, we‚Äôll extend the functionality of your robot by adding sensors, allowing it to interact with its environment. You‚Äôll start by integrating photoresistors to guide your robot toward the brightest üåü light üåü. </p>
      <p>Then, you‚Äôll choose another sensor to give your robot additional behaviors, such as obstacle avoidance or wall following. By the end of the lab, your robot will sense and adapt to its surroundings autonomously.</p>
    </div>

    <!-- SAFETY -->
    <div class="section">
      <h2>ü¶∫ Safety & Important Tips</h2>
      <p><strong>(1 minute read)</strong></p>
      <ul>
        <li>Unpower your circuit when making any change</li>
        <li>Double check your wiring before plugging in</li>
        <li>Watch for solder bridges</li>
        <li>Components can be fragile‚Äîtreat them carefully</li>
      </ul>
    </div>

    <!-- FABRICATION QUEST -->
    <div class="section">
      <h2>üî® Fabrication Quest of the Day</h2>
      <p>Today, you will use sensors to do closed-loop control of your robotic car:</p>
      <ul>
        <li>Understand how to read values from various sensors with your Arduino</li>
        <li>Use photoresistors to guide the robot toward light</li>
        <li>Implement a new behavior using an additional sensor</li>
      </ul>
    </div>

    <!-- SOFTWARE & HARDWARE -->
    <div class="section">
      <h2>üèóÔ∏è Software & Hardware</h2>
      <p><strong>Software:</strong> Arduino IDE</p>
      <p><strong>Hardware:</strong> Assembled Mr. Roboto from previous lab, Ultrasonic Sensor + Bracket, Jumper Wires, Photoresistors (3x), 10kŒ© Resistors (3x), Flashlight (x1), Misc sensors for Remix (color, IMU, ultrasonic etc.)</p>
      <p><strong>Machines:</strong> Soldering Iron</p>
    </div>

    <!-- PART 1 -->
    <div class="section">
      <h2>Part 1: Reading Values from Photoresistors (1 hour)</h2>
      <p>We‚Äôll start with the simplest sensor: the photoresistor. It allows us to measure brightness and guide our robot toward light. ‚ö†Ô∏è Unplug your Arduino before breadboarding ‚ö†Ô∏è</p>
      <ol>
        <li>Wire the photoresistor and 10kŒ© resistor on the breadboard as shown. Yellow ‚Üí A0, Red ‚Üí 5V, Black ‚Üí GND to create a voltage divider. <img src="cat1.png" class="inline" alt="Photoresistor wiring"></li>
        <li>Read values via analog pin A0. Use the following code:
        <pre><code>#include &lt;AFMotor.h&gt;

// Pin assignments for photoresistors
const int Photoresistor = A0;

void setup() {
    Serial.begin(9600); // Initialize Serial Monitor
}

void loop() {
    int photoValue = analogRead(Photoresistor);
    Serial.print("PhotoResistor: ");
    Serial.println(photoValue);
    delay(20);
}
</code></pre></li>
        <li>Check the ambient value in the room, then shine your flashlight directly to see max value.</li>
        <p><span class="checkoff">Checkoff 1:</span> Ask your instructor to verify adding/testing photoresistor and show serial monitor values.</p>
        <li>Add 2 more resistors and photoresistors pair, wiring to A1 and A2. Ensure you have spaced them out and 
          angled them slightly forward. Refer to images below
          <img src="cat2.png" class="inline"><img src="cat3.png" class="inline"></li>
        <li>Adjust the following code to print the new values. How consistent are the values between each photoresistor?"
        <pre><code>#include &lt;AFMotor.h&gt;

// Pin assignments
const int rightPhotoresistor = A0;
const int middlePhotoresistor = A1;
const int leftPhotoresistor = A2;

void setup() {
    Serial.begin(9600);
}

void loop() {
    int rightValue = analogRead(rightPhotoresistor);
    int middleValue = analogRead(middlePhotoresistor);
    int leftValue = analogRead(leftPhotoresistor);

    Serial.print("Left: "); Serial.print(leftValue);
    Serial.print("  Middle: "); Serial.print(middleValue);
    Serial.print("  Right: "); Serial.println(rightValue);
    delay(20);
}
</code></pre>
        </li>
        <p><span class="checkoff">Checkoff 2:</span> Show serial monitor values and answer why extra photoresistors were added.</p>
      </ol>
    </div>

    <!-- PART 2 -->
    <div class="section">
      <h2>Part 2: Determining Ambient Light</h2>
      <p>Now we can read the values from our photoresistor. Before we write an algorithm for our robot to follow a bright light, we should clean our sensor data. Our algorithm will decide the driving direction based off differences between sensors, so we want to amplify the difference. A bright room will have high base values for all sensors and the change from a flashlight will be relatively small. We will subtract the ambient value from the sensors.
        Write the values for the ambient values of each sensor. Put above setup():</p>
     <pre><code>
// Threshold for ambient light
const int ambientThresholdR = ;
const int ambientThresholdM = ;
const int ambientThresholdL = ;
</code></pre>

<p>Subtract it from the analog reading in your <code>loop()</code> function:</p>

<pre><code>
// In loop():
int rightValue = analogRead(rightPhotoresistor) - ambientThresholdR;
int middleValue = analogRead(middlePhotoresistor) - ambientThresholdM;
int leftValue = analogRead(leftPhotoresistor) - ambientThresholdL;
</code></pre>

      <p><span class="checkoff">Checkoff 2:</span> Ask instructor to verify adjusted values.</p>
    </div>

    <!-- PART 3 -->
    <div class="section">
      <h2>Part 3: Writing a Nicer Motor Function</h2>
      <p>Now, explicitly having to set motor direction every time we want to reverse is inefficient. Let's make a more convenient function that can command our motors from a range of -255 to 255 instead of 0-255.

Fill in the if/else conditions below and place these functions at the bottom of the script.</p>
      <pre><code>#include &lt;AFMotor.h&gt;

AF_DCMotor rightMotor(1);  // Motor connected to M1
AF_DCMotor leftMotor(2);   // Motor connected to M2

void setLeftSpeed(int value) {
    if (value &gt; ??) { leftMotor.setSpeed(value); leftMotor.run(FORWARD); }
    else if (value &lt; ??) { leftMotor.setSpeed(-value); leftMotor.run(BACKWARD); }
    else { leftMotor.run(RELEASE); }
}

void setRightSpeed(int value) {
    if (value &gt; ??) { rightMotor.setSpeed(value); rightMotor.run(FORWARD); }
    else if (value &lt; ??) { rightMotor.setSpeed(-value); rightMotor.run(BACKWARD); }
    else { rightMotor.run(RELEASE); }
}
</code></pre>
      <p> We can call our function in the same way we call any other function. Now, for the sake of testing, we will change the speed/direction of the left and right motors depending on the values of the left and right photoresistors. This allows us to test our new function. Add the following lines to your script. When you shine your light on the left/right photoresistor,
        the left/right motor should spin forward, and when you cover the left/right photoresistor, the left/right motor spin backwards.</p>
         <pre><code>
// Test motor reaction to light values
setLeftSpeed(leftValue);
setRightSpeed(rightValue);
</code></pre>
      
      <p><span class="checkoff">Checkoff 3:</span> Verify motor speed changes in response to photoresistors.</p>
    </div>

    <!-- PART 4 -->
    <div class="section">
      <h2>Part 4: Light Following BANG-BANG</h2>
      <p>The field of robotics control is enormous. The robot we have made is simple, but with good sensors and control it can exhibit complex behavior such as light following and wall following.
        We will start with a controller called a BANG-BANG controller and then move to a proportional controller. The code for these controllers is relatively brief but most of the work comes from tuning their constants for better performance. For best performance, you should copy your straight line speeds from the previous lab into the base speeds here.

Bang-Bang Controller.
This controller detects which directions has higher light intensity and applies a constant "speed-boost" to one of the motors to turn in the required direction. 
        When there is little variation between the photoresistors or the overall light level is too low, the motors are turned off. Adjust the variation threshold
      and bang constant.</p>
      <pre><code>
const int variationThreshold = 50; // Minimum difference between sensors to trigger movement
const int bang = 50;

void setup() {
    Serial.begin(9600); // Initialize Serial Monitor

    // Set initial motor speed
    setLeftSpeed();  // TODO: Copy speed from previous section
    setRightSpeed();
}

void loop() {
    // Read light intensity from photoresistors
    int rightValue = analogRead(rightPhotoresistor) - ambientThresholdR;
    int middleValue = analogRead(middlePhotoresistor) - ambientThresholdM;
    int leftValue = analogRead(leftPhotoresistor) - ambientThresholdL;

    // Print sensor values to Serial Monitor for debugging
    Serial.print("Left: ");
    Serial.print(leftValue);
    Serial.print("  Middle: ");
    Serial.print(middleValue);
    Serial.print("  Right: ");
    Serial.println(rightValue);

    // TODO: Calculate the average light level
    int averageLight = ;

    // Determine if there is little variation in light intensity
    int maxDifference = max(abs(middleValue - leftValue), abs(middleValue - rightValue));

    // Light is ambient or too uniform; stop the robot (Hint: || is OR)
    if () {
        setLeftSpeed(0);
        setRightSpeed(0);
    } else if () {
        // Middle light is greater than left AND right (Hint: && is AND)
        setLeftSpeed(100);
        setRightSpeed(100);
    } else if () {
        // Brightest light is to the left; turn left
        setLeftSpeed(100);
        setRightSpeed(100 + bang);
    } else if () {
        // Brightest light is to the right; turn right
        setLeftSpeed(100 + bang);
        setRightSpeed(100);
    }

    delay(50); // Small delay for stability
}
</code></pre>
      <p><span class="checkoff">Checkoff 4:</span> Ask your instructor for a check-off on completing Part (4). Show the robot following the light.</p>
    </div>

    <!-- PART 5 -->
    <div class="section">
      <h2>Part 5: Light Following Proportional Controller</h2>
      <p>Proportional control is the first step of a PID controller (a classic controller used all over robotics). 
        This controller changes the size of the speed boost based off the amount of light intensity deviation between the middle and sides. 
        The response is proportional to the error instead of a constant value like in BANG-BANG. Here, the error is the amount by which one side is greater than the middle. 
        The new constant to adjust is the proportional constant which multiplies this error to result in a motor command. 
        We will change the proportional constant for a stronger/weaker response.</p>
      <pre><code>
const float Kp = 1.0; // Proportional gain for the controller VALUE TO CHANGE
const int BASE_SPEED = 80;

void setup() {
    Serial.begin(9600); // Initialize Serial Monitor
}

void loop() {
    // Read light intensity from photoresistors
    int rightValue = analogRead(rightPhotoresistor) - ambientThresholdR;
    int middleValue = analogRead(middlePhotoresistor) - ambientThresholdM;
    int leftValue = analogRead(leftPhotoresistor) - ambientThresholdL;

    // Print sensor values to Serial Monitor for debugging
    Serial.print("Left: ");
    Serial.print(leftValue);
    Serial.print("  Middle: ");
    Serial.print(middleValue);
    Serial.print("  Right: ");
    Serial.println(rightValue);

    // Calculate the average light level
    int averageLight = ;

    if () {
        // Light is ambient or too uniform; stop the robot
        setLeftSpeed(0);
        setRightSpeed(0);
    } else {
        // Calculate error signals for proportional control
        if (leftValue > rightValue) {
            int error = middleValue - leftValue;
        }
        else{
            int error = - (middleValue - rightValue);
        }

        // Calculate motor speeds based on proportional control
        int leftSpeed = BASE_SPEED + Kp * error;
        int rightSpeed = BASE_SPEED - Kp * error;

        // Set motor speeds and directions
        setLeftSpeed(leftSpeed);
        setRightSpeed(rightSpeed);
    }

    delay(50); // Small delay for smoother control
}
                    
</code></pre>
      <p><span class="checkoff">Checkoff 5:</span> Show proportional control in action.</p>
    </div>

    <!-- PART 6 -->
    <div class="section">
      <h2>Part 6: Ultrasound Connection</h2>
      <img src="cat4.png" class="inline" alt="Ultrasound wiring">
      <p>While the photoresistors are a rather simple sensor, the framework we have made will allow us to slot in another more complex sensor.
        We will use a ultrasonic distance sensor to follow a wall. Connect HC-SR04 with servo. Use double female header to access pins 5 and 6. 
        Vcc ‚Üí 5V, Trig ‚Üí 5, Echo ‚Üí 6, GND ‚Üí GND.</p>
      <p>Unfortunately, the motor shield blocks our access to the digital PWM pins which we need for this sensor. 
        Its not elegant, but we can solder a double female header to the back pins. UNPOWER YOUR SYSTEM. Have an instuctor help you do this to pins 5 and 6. 
        Then, plug the HC-SR04 Vcc, Trig, Echo, GND into 5v, pin 5, pin 6, and GND respectively.</p>


      <p><span class="checkoff">Checkoff 6:</span> Verify wiring of ultrasonic sensor with your instructors.</p>
    </div>

    <!-- PART 7 -->
    <div class="section">
      <h2>Part 7: Using the Ultrasound</h2>
      <p>This is a very common sensor and there are many tutorials of how to use it online. You will rarely know exactly how to program a sensor from memory.
        Use the internet to make/find a function called measureDistance() that returns an integer of the distance from the ultrasonic sensor. 
        Then, upload the following code and move your hand in front of the ultrasonic sensor and make sure it responds as you expect.</p>
      <img src="cat6.png" class="inline" alt="Ultrasound">
      <pre><code>
// Pin assignments for HC-SR04
const int trigPin = 5;  // Trigger pin 
const int echoPin = 6; // Echo pin

void setup() {
    Serial.begin(9600); // Initialize Serial Monitor

    // Set up HC-SR04 pins
    pinMode(trigPin, OUTPUT);
    pinMode(echoPin, INPUT);
}

void loop() {
    // Measure distance using HC-SR04
    int distance = measureDistance();

    Serial.print("Distance: ");
    Serial.print(distance);

    delay(20);
</code></pre>
      <p><span class="checkoff">Checkoff 7:</span> Ask your instructor for a check-off on completing Part (7). Show the ultrasound working..</p>
    </div>

    <!-- PART 8 -->
    <div class="section">
      <h2>Part 8: Wall Following</h2>
      <img src="cat7.png" class="inline" alt="Wall following setup">
       <p>Now we can use this function and our proportional controller to track a wall. Angle your ultrasonic sensor at about 80degrees from straight forward 
        (pointing mostly left). It is important that it is not at 90 degrees.
        (Mirror of the image below).
       The following code follows a right wall. Alter it and tune the proportional constants to follow a left wall.</p>
      <pre><code>
// Pin assignments for HC-SR04
const int trigPin = 5;  // Trigger pin 
const int echoPin = 6; // Echo pin

// Create motor objects for two motors
AF_DCMotor rightMotor(1);  // Motor connected to M1
AF_DCMotor leftMotor(2); // Motor connected to M2

// Desired distance from the wall (in cm)
const int targetDistance = 25; // Adjust as needed

// Proportional control gains
const float KpLeft = 1.0;  // Proportional gain for the left motor
const float KpRight = 1.0; // Proportional gain for the right motor

// Base motor speed (0-255)
const int baseSpeedLeft = 60;
const int baseSpeedRight = 60;

void setup() {
    Serial.begin(9600); // Initialize Serial Monitor

    // Set up HC-SR04 pins
    pinMode(trigPin, OUTPUT);
    pinMode(echoPin, INPUT);
}

void loop() {
    // Measure distance using HC-SR04
    int distance = measureDistance();

    // Calculate the error
    int error = targetDistance - distance;

    // Calculate speed adjustments based on proportional control
    int leftAdjustment = KpLeft * error;
    int rightAdjustment = KpRight * error;

    // Determine motor speeds
    int leftMotorSpeed = constrain(baseSpeedLeft - leftAdjustment, 0, 100);
    int rightMotorSpeed = constrain(baseSpeedRight + rightAdjustment, 0, 100);

    // Print debugging information
    Serial.print("Distance: ");
    Serial.print(distance);
    Serial.print(" cm  Error: ");
    Serial.print(error);
    Serial.print("  Left Speed: ");
    Serial.print(leftMotorSpeed);
    Serial.print("  Right Speed: ");
    Serial.println(rightMotorSpeed);

    // Apply motor speeds straight movement
    setLeftSpeed(leftMotorSpeed);
    setRightSpeed(rightMotorSpeed);

    delay(50); // Small delay for stability
}
                    
                    
</code></pre>
      <p><span class="checkoff">Checkoff 8:</span>Ask your instructor for a check-off on completing Part (8) Wall Following.</p>
    
    </div>

    <!-- PART 9 -->
    <div class="section">
      <h2>Part 9: Remix Sensor</h2>
      <p>Now that know how to write code for a given sensor, pick a sensor/output that you think will be useful for your project and make it work. 
        This could be spinning a stepper motor, using a temperature or color sensor, or even the IMU. If you are unsure of a direction, ask your instructor for 
        suggestions.
        Below is a list of inputs and outputs you can use.</p>
      <ul>
        <li>Color sensor</li>
        <li>IR transmitter & receiver</li>
        <li>IMU</li>
        <li>Temperature sensor</li>
        <li>LCD/OLED</li>
        <li>Servo motor</li>
        <li>Stepper motor</li>
      </ul>
      <p><span class="checkoff">Checkoff 9:</span> Verify implementation of your chosen sensor/output.</p>
    </div>

  </div>

  <!-- SIDEBAR -->

<div class="sidebar">
  <img src="cat10.png" alt="Robot sensors sidebar">
  <img src="cat22.png" class="inline" alt="Fun Star Wars image">
  <p style="text-align:center; color:#c29fff; font-weight:bold; font-size:1.1em; margin-top:10px;">
    Patience, young Padawan‚Ä¶ debugging is part of the training.
  </p>
</div>

</div> <!-- end of container -->

<footer>
  All instructions credited to MISTI Teaching Team | UTB Student Labs 2025
</footer>

</body>
</html>



